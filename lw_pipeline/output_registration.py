"""Output registration system for pipeline steps."""

# Authors: The Lightweight Pipeline developers
# SPDX-License-Identifier: BSD-3-Clause

import functools
from fnmatch import fnmatch


def register_output(name, description="", enabled_by_default=True, group=None):
    """
    Register a method as an optional output generator.

    This allows steps to define multiple outputs that can be selectively
    generated based on CLI arguments or config settings.

    Parameters
    ----------
    name : str
        Name of the output (used for CLI selection, e.g., "plot", "stats").
    description : str, optional
        Human-readable description of the output.
    enabled_by_default : bool, optional
        Whether this output is generated by default. Default is True.
    group : str, optional
        Optional group name for categorization (future use).

    Returns
    -------
    callable
        Decorated function.

    Examples
    --------
    >>> class MyStep(Pipeline_Step):
    ...     @register_output("plot", "Channel plot", enabled_by_default=True)
    ...     def generate_plot(self):
    ...         if not self.should_generate_output("plot"):
    ...             return
    ...         fig, ax = plt.subplots()
    ...         # ... create plot ...
    ...         self.output_manager.save_figure(fig, "channel_plot")
    """
    def decorator(func):
        # Store registration info as function attributes
        func._is_registered_output = True
        func._output_name = name
        func._output_description = description
        func._output_enabled_by_default = enabled_by_default
        func._output_group = group

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)

        return wrapper

    return decorator


class Output_Registry:
    """
    Registry for managing registered outputs in a pipeline step.

    This class is used internally by Pipeline_Step to track and filter
    registered outputs.
    """

    def __init__(self, step_instance):
        """
        Initialize the registry for a pipeline step.

        Parameters
        ----------
        step_instance : Pipeline_Step
            The step instance to scan for registered outputs.
        """
        self.step = step_instance
        self._registered = {}
        self._scan_step_for_outputs()

    def _scan_step_for_outputs(self):
        """Scan the step instance for methods decorated with @register_output."""
        for attr_name in dir(self.step):
            # Skip private attributes and output_registry to avoid recursion
            if attr_name.startswith("_") or attr_name == "output_registry":
                continue

            attr = getattr(self.step, attr_name)
            if callable(attr) and getattr(attr, "_is_registered_output", False):
                output_info = {
                    "name": attr._output_name,
                    "description": attr._output_description,
                    "enabled_by_default": attr._output_enabled_by_default,
                    "group": attr._output_group,
                    "method": attr,
                }
                self._registered[attr._output_name] = output_info

    def get_all(self):
        """
        Get all registered outputs.

        Returns
        -------
        dict
            Dictionary mapping output names to their info.
        """
        return self._registered.copy()

    def get_enabled_by_default(self):
        """
        Get outputs that are enabled by default.

        Returns
        -------
        list
            List of output names enabled by default.
        """
        return [
            name for name, info in self._registered.items()
            if info["enabled_by_default"]
        ]

    def should_generate(self, output_name, config):
        """
        Determine if an output should be generated.

        Parameters
        ----------
        output_name : str
            Name of the output to check.
        config : Config
            Configuration object with outputs_to_generate and outputs_to_skip settings.

        Returns
        -------
        bool
            True if output should be generated.
        """
        # Check if output is registered
        if output_name not in self._registered:
            return False

        # Check if output is explicitly skipped (takes precedence)
        outputs_skip = getattr(config, "outputs_to_skip", None)
        if outputs_skip is not None:
            if self._matches_patterns(output_name, outputs_skip):
                return False

        # Get configuration for outputs to generate
        outputs_config = getattr(config, "outputs_to_generate", None)

        # If no config specified, use default behavior
        if outputs_config is None:
            return self._registered[output_name]["enabled_by_default"]

        # Check if output matches the patterns
        return self._matches_patterns(output_name, outputs_config)

    def _matches_patterns(self, output_name, patterns_config):
        """
        Check if an output name matches any pattern in the config.

        Parameters
        ----------
        output_name : str
            Name of the output to check.
        patterns_config : dict or list
            Configuration with patterns (dict for step-scoped, list for global).

        Returns
        -------
        bool
            True if output matches any pattern.
        """
        # Check if patterns_config is dict (step-scoped) or list (global)
        if isinstance(patterns_config, dict):
            step_id = self.step.short_id
            
            # Check for exact step match
            patterns = patterns_config.get(step_id, None)
            
            # If no exact match, check for wildcard "*" (applies to all steps)
            if patterns is None and "*" in patterns_config:
                patterns = patterns_config["*"]

            # If this step not in config, return False (doesn't match)
            if patterns is None:
                return False

            # Check if output name matches any pattern
            return any(fnmatch(output_name, pattern) for pattern in patterns)

        elif isinstance(patterns_config, list):
            # Global patterns apply to all steps
            return any(fnmatch(output_name, pattern) for pattern in patterns_config)

        else:
            # Unknown config format, return False
            return False

    def list_outputs(self, include_disabled=True):
        """
        List all registered outputs with their information.

        Parameters
        ----------
        include_disabled : bool, optional
            Include outputs that are disabled by default. Default is True.

        Returns
        -------
        list
            List of tuples (name, description, enabled_by_default).
        """
        outputs = []
        for name, info in self._registered.items():
            if include_disabled or info["enabled_by_default"]:
                outputs.append((
                    name,
                    info["description"],
                    info["enabled_by_default"]
                ))
        return outputs
